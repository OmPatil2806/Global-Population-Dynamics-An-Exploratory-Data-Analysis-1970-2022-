# -*- coding: utf-8 -*-
"""Population_App.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1U98Zs4FDCF5nVsDFGhZuWQRIiN4TNqN3
"""

!pip install streamlit pyngrok plotly seaborn

!pip install streamlit
!npm install -g localtunnel

from google.colab import files
uploaded = files.upload()

print("\nUploaded files:")
for fn in uploaded.keys():
    print("‚úî", fn)

from pyngrok import ngrok

# Paste your ngrok token here
ngrok.set_auth_token("366Hjgj2lHm3lzXxubFqcTbVx7y_3w2re6wbcGw2be51oaM2U")

# Commented out IPython magic to ensure Python compatibility.
# %%writefile app.py
# import streamlit as st
# import pandas as pd
# import numpy as np
# import plotly.express as px
# from io import BytesIO
# 
# # ----------------------------------------------------------
# # PAGE CONFIG
# # ----------------------------------------------------------
# st.set_page_config(
#     page_title="World Population Dashboard",
#     layout="wide",
#     page_icon="üåç"
# )
# 
# # ----------------------------------------------------------
# # DARK MODE CUSTOM CSS
# # ----------------------------------------------------------
# st.markdown("""
#     <style>
#     .stApp {
#         background-color: #0f172a;
#         color: #e2e8f0;
#     }
#     .header {
#         font-size: 32px;
#         font-weight: 800;
#         color: #38bdf8;
#         text-shadow: 0 0 10px rgba(56,189,248,0.7);
#     }
#     .subheader {
#         font-size: 15px;
#         color: #cbd5e1;
#     }
#     .card {
#         background: #1e293b;
#         padding: 18px;
#         border-radius: 12px;
#         border: 1px solid rgba(56,189,248,0.4);
#         box-shadow: 0 0 15px rgba(56,189,248,0.3);
#     }
#     .kpi {
#         font-size: 18px;
#         color: #38bdf8;
#         font-weight: 700;
#         margin-bottom: 5px;
#     }
#     </style>
# """, unsafe_allow_html=True)
# 
# 
# # ----------------------------------------------------------
# # LOAD DATA
# # ----------------------------------------------------------
# @st.cache_data
# def load_data(path):
#     return pd.read_csv(path)
# 
# 
# @st.cache_data
# def convert_df(df):
#     buf = BytesIO()
#     df.to_csv(buf, index=False)
#     buf.seek(0)
#     return buf
# 
# 
# # ----------------------------------------------------------
# # CLEAN COUNTRY NAMES (IMPORTANT FOR MAP)
# # ----------------------------------------------------------
# def clean_country_names(df, col):
#     df[col] = df[col].astype(str)
# 
#     replacements = {
#         "United States": "United States of America",
#         "US": "United States of America",
#         "USA": "United States of America",
#         "U.S.": "United States of America",
#         "UAE": "United Arab Emirates",
#         "U.A.E": "United Arab Emirates",
#         "Korea, South": "South Korea",
#         "Korea, North": "North Korea",
#         "Russia": "Russian Federation",
#         "Czechia": "Czech Republic",
#     }
# 
#     df[col] = df[col].replace(replacements)
#     df[col] = df[col].str.replace(r"\(.*\)", "", regex=True).str.strip()
# 
#     return df
# 
# 
# # ----------------------------------------------------------
# # HEADER
# # ----------------------------------------------------------
# st.markdown("<div class='header'>üåç World Population ‚Äî Interactive Dashboard</div>", unsafe_allow_html=True)
# st.markdown("<div class='subheader'>Deep analysis of global population patterns, growth, regions, and historical trends.</div>", unsafe_allow_html=True)
# st.write("")
# 
# 
# # ----------------------------------------------------------
# # FILE UPLOADER
# # ----------------------------------------------------------
# uploaded = st.file_uploader("/content/World_population_cleaned.csv", type=["csv"])
# 
# if uploaded:
#     df = pd.read_csv(uploaded)
# else:
#     try:
#         df = load_data("World_population_cleaned.csv")
#         st.success("Loaded default dataset successfully.")
#     except:
#         st.error("Upload a CSV to continue.")
#         st.stop()
# 
# 
# # ----------------------------------------------------------
# # AUTO COLUMN DETECTION
# # ----------------------------------------------------------
# df_cols = df.columns.tolist()
# num_cols = df.select_dtypes(include=[np.number]).columns.tolist()
# 
# year_col = next((c for c in df_cols if "year" in c.lower()), None)
# country_col = next((c for c in df_cols if c.lower() in ["country", "name", "location"]), None)
# region_col = next((c for c in df_cols if "region" in c.lower() or "continent" in c.lower()), None)
# pop_col = next((c for c in df_cols if "pop" in c.lower()), None)
# 
# 
# def safe_index(col):
#     return df_cols.index(col) if col in df_cols else 0
# 
# 
# # ----------------------------------------------------------
# # SIDEBAR CONFIG
# # ----------------------------------------------------------
# st.sidebar.header("‚öôÔ∏è Configure Dataset Columns")
# 
# year_col = st.sidebar.selectbox("Year Column", df_cols, index=safe_index(year_col))
# country_col = st.sidebar.selectbox("Country Column", df_cols, index=safe_index(country_col))
# region_col = st.sidebar.selectbox("Region Column", df_cols, index=safe_index(region_col))
# pop_col = st.sidebar.selectbox("Population Column", df_cols, index=safe_index(pop_col))
# 
# 
# # ----------------------------------------------------------
# # KPI CARDS
# # ----------------------------------------------------------
# k1, k2, k3, k4 = st.columns(4)
# 
# latest_year = df[year_col].max()
# total_countries = df[country_col].nunique()
# latest_pop = int(df[df[year_col] == latest_year][pop_col].sum())
# 
# # YoY Growth
# growth_pct = None
# years_sorted = sorted(df[year_col].unique())
# if len(years_sorted) > 1:
#     last = df[df[year_col] == years_sorted[-1]][pop_col].sum()
#     prev = df[df[year_col] == years_sorted[-2]][pop_col].sum()
#     growth_pct = ((last - prev) / prev * 100) if prev != 0 else None
# 
# growth_text = f"{growth_pct:.2f}%" if growth_pct else "N/A"
# 
# 
# k1.markdown(f"<div class='card'><div class='kpi'>Countries</div><div style='font-size:24px'>{total_countries}</div></div>", unsafe_allow_html=True)
# k2.markdown(f"<div class='card'><div class='kpi'>Latest Year</div><div style='font-size:24px'>{latest_year}</div></div>", unsafe_allow_html=True)
# k3.markdown(f"<div class='card'><div class='kpi'>Total Population</div><div style='font-size:24px'>{latest_pop:,}</div></div>", unsafe_allow_html=True)
# k4.markdown(f"<div class='card'><div class='kpi'>YoY Growth %</div><div style='font-size:24px'>{growth_text}</div></div>", unsafe_allow_html=True)
# 
# st.write("---")
# 
# 
# # ----------------------------------------------------------
# # SIDEBAR FILTERS
# # ----------------------------------------------------------
# st.sidebar.header("üîç Data Filters")
# 
# selected_year = st.sidebar.selectbox("Filter by Year", ["All"] + sorted(df[year_col].unique().tolist()))
# selected_region = st.sidebar.multiselect("Filter by Region", df[region_col].unique().tolist())
# top_n = st.sidebar.slider("Top N Countries", 5, 30, 10)
# 
# df_f = df.copy()
# if selected_year != "All":
#     df_f = df_f[df_f[year_col] == selected_year]
# if selected_region:
#     df_f = df_f[df_f[region_col].isin(selected_region)]
# 
# 
# # ----------------------------------------------------------
# # TOP / BOTTOM COUNTRIES
# # ----------------------------------------------------------
# st.subheader("üìå Top & Bottom Countries by Population")
# col1, col2 = st.columns(2)
# 
# with col1:
#     st.write("### üîº Top Countries")
#     st.dataframe(df_f.sort_values(pop_col, ascending=False).head(top_n)[[country_col, pop_col]])
# 
# with col2:
#     st.write("### üîΩ Bottom Countries")
#     st.dataframe(df_f.sort_values(pop_col).head(top_n)[[country_col, pop_col]])
# 
# st.write("---")
# 
# 
# # ----------------------------------------------------------
# # COUNTRY LINE CHART
# # ----------------------------------------------------------
# st.subheader("üìà Country Population Trend")
# 
# selected_country = st.selectbox("Select Country", df[country_col].unique())
# df_ct = df[df[country_col] == selected_country].sort_values(year_col)
# 
# fig = px.line(
#     df_ct, x=year_col, y=pop_col, markers=True,
#     title=f"{selected_country} ‚Äî Population Over Time",
#     template="plotly_dark"
# )
# st.plotly_chart(fig, use_container_width=True)
# 
# st.write("---")
# 
# 
# # ----------------------------------------------------------
# # REGION-WISE AREA CHART
# # ----------------------------------------------------------
# st.subheader("üåê Region-wise Population Trends")
# 
# region_data = df.groupby([year_col, region_col])[pop_col].sum().reset_index()
# 
# fig = px.area(
#     region_data, x=year_col, y=pop_col, color=region_col,
#     title="Population Growth by Region",
#     template="plotly_dark"
# )
# st.plotly_chart(fig, use_container_width=True)
# 
# st.write("---")
# 
# 
# # ----------------------------------------------------------
# # WORLD MAP
# # ----------------------------------------------------------
# st.subheader("üó∫Ô∏è Global Population Map")
# 
# map_year = st.selectbox("Select Year", sorted(df[year_col].unique(), reverse=True))
# df_map = df[df[year_col] == map_year].copy()
# 
# # Clean country names before mapping
# df_map = clean_country_names(df_map, country_col)
# 
# try:
#     fig = px.choropleth(
#         df_map,
#         locations=country_col,
#         locationmode="country names",
#         color=pop_col,
#         title=f"World Population Map ‚Äî {map_year}",
#         color_continuous_scale="Plasma",
#         template="plotly_dark",
#     )
#     st.plotly_chart(fig, use_container_width=True)
# 
# except Exception as e:
#     st.error("‚ùå Map could not be rendered. Invalid country names.")
#     st.code(str(e))
# 
# 
# 
# # ----------------------------------------------------------
# # DISTRIBUTION + CORRELATION
# # ----------------------------------------------------------
# st.subheader("üìä Distribution & Correlation Analysis")
# 
# num_col = st.selectbox("Select Numeric Column", num_cols)
# 
# fig = px.histogram(
#     df, x=num_col, nbins=40,
#     title=f"Distribution of {num_col}",
#     template="plotly_dark"
# )
# st.plotly_chart(fig, use_container_width=True)
# 
# corr_matrix = df[num_cols].corr()
# fig = px.imshow(
#     corr_matrix,
#     text_auto=True,
#     color_continuous_scale="darkmint",
#     title="Correlation Matrix",
#     template="plotly_dark"
# )
# st.plotly_chart(fig, use_container_width=True)
# 
# st.write("---")
# 
# 
# # ----------------------------------------------------------
# # DOWNLOAD CSV
# # ----------------------------------------------------------
# st.subheader("üíæ Download Processed Dataset")
# 
# csv_file = convert_df(df)
# 
# st.download_button(
#     "Download CSV",
#     csv_file,
#     "processed_population.csv",
#     "text/csv"
# )
# 
# st.write("Made with üíô by **Om Patil** ‚Äî Data Science Enthusiast")
#

# Start Streamlit and expose via ngrok
from pyngrok import ngrok
import time, os, subprocess, signal

# Set auth token
ngrok.set_auth_token("366Hjgj2lHm3lzXxubFqcTbVx7y_3w2re6wbcGw2be51oaM2U")

# Kill any existing streamlit/port processes (safe restart)
!pkill -f streamlit || true

# Run streamlit in background
get_ipython().system_raw("streamlit run app.py --server.port 8501 &")

# Wait for server to start
time.sleep(2)

public_url = ngrok.connect(8501)
print("Public URL:", public_url)
print("Open the URL above to view your dashboard. It may take a few seconds to load.")